루비 온 레일즈에서는 자바와 같은 정적 타입 언어에서 흔히 사용되는 디자인 패턴들이 다소 다르게 적용되거나 덜 사용될 수 있습니다. 그 이유는 루비의 동적 특성과 메타프로그래밍 능력 때문입니다. Template Method 패턴도 그 중 하나입니다.

Template Method 패턴 (Service - Processor)
Template Method 패턴은 상위 클래스에서 알고리즘의 구조를 정의하고, 하위 클래스에서 일부 단계를 구현하도록 하는 디자인 패턴입니다. 이는 코드의 재사용성을 높이고, 알고리즘의 변하지 않는 부분과 변할 수 있는 부분을 분리하는 데 유용합니다.

루비 온 레일즈에서의 사용
동적 특성 활용:

루비는 메타프로그래밍과 동적 메서드 정의를 통해 유연하게 코드를 작성할 수 있습니다. 이러한 특성 덕분에 Template Method 패턴을 명시적으로 구현하지 않고도 비슷한 효과를 얻을 수 있습니다.
모듈과 믹스인(Mixin):

루비에서는 모듈과 믹스인을 사용하여 공통 기능을 공유할 수 있습니다. 이는 Template Method 패턴의 일부 기능을 대체할 수 있습니다. 공통 로직을 모듈로 정의하고 필요한 클래스에 포함시켜 사용하는 방식입니다.
콜백과 훅 메서드:

루비 온 레일즈는 콜백과 훅 메서드를 통해 특정 이벤트 전후에 실행할 코드를 정의할 수 있습니다. 이는 Template Method의 일부 역할을 수행할 수 있습니다. 예를 들어, ActiveRecord의 콜백 메서드를 사용하여 데이터베이스 작업 전후에 특정 로직을 실행할 수 있습니다.
명시적 구현의 드물음:

루비 커뮤니티에서는 Template Method 패턴을 명시적으로 구현하는 경우가 드뭅니다. 대신, 루비의 유연한 문법과 강력한 메타프로그래밍 기능을 활용하여 비슷한 구조를 구현하는 것이 일반적입니다.
결론
루비 온 레일즈에서는 Template Method 패턴을 자바처럼 명시적으로 구현하기보다는, 루비의 동적 특성과 메타프로그래밍을 활용하여 비슷한 구조를 더 간결하게 구현하는 경향이 있습니다. 이는 루비의 언어적 특성과 철학에 맞춘 자연스러운 접근 방식입니다.




## 자바에서 많이 쓰는 패턴

템플릿 메서드 패턴 (Template Method Pattern)
상위 클래스에서 알고리즘의 구조 정의: SettleableProfitTransferProcessor 클래스가 상위 클래스 역할을 하며, 알고리즘의 기본 구조를 정의합니다. 이 클래스는 processProfitSettlementLog와 같은 메서드를 추상 메서드로 정의하고, 하위 클래스에서 구체적인 구현을 제공합니다.
하위 클래스에서 세부 구현: WithdrawSettleableProfitTransferProcessor 클래스는 SettleableProfitTransferProcessor를 상속받아, 특정 타입의 이익 정산 처리에 대한 구체적인 구현을 제공합니다. 이 클래스는 processProfitSettlementLog 메서드를 오버라이드하여 세부적인 처리를 구현합니다.
전략 패턴 (Strategy Pattern)
전략 선택 및 실행: SettleableProfitTransferService 클래스는 여러 SettleableProfitTransferProcessor 구현체를 가지고 있으며, supports 메서드를 통해 적절한 프로세서를 선택하여 실행합니다. 이는 전략 패턴의 핵심 아이디어인 "행위를 캡슐화하고, 필요에 따라 변경할 수 있도록 하는 것"을 구현한 것입니다.
동적 전략 결정: process, denied, unProcess 메서드에서 요청 타입에 따라 적절한 프로세서를 선택하여 해당 메서드를 호출합니다. 이는 런타임에 전략을 선택하고 실행할 수 있게 해줍니다.
결론
이 코드는 템플릿 메서드 패턴을 통해 알고리즘의 구조를 정의하고, 전략 패턴을 통해 다양한 구현체 중 하나를 선택하여 실행하는 구조를 가지고 있습니다. 이러한 조합은 코드의 유연성과 확장성을 높이는 데 기여합니다. 각 프로세서는 특정 유형의 작업을 처리할 수 있도록 설계되어 있으며, 새로운 프로세서가 필요할 경우 쉽게 추가할 수 있습니다.



템플릿 메서드 패턴
용도: 알고리즘의 구조를 정의하고, 알고리즘의 일부 단계를 하위 클래스에서 구현하도록 할 때 사용합니다. 상위 클래스에서 알고리즘의 골격을 제공하고, 하위 클래스에서 구체적인 구현을 제공합니다.
장점: 코드의 중복을 줄이고, 알고리즘의 변하지 않는 부분과 변할 수 있는 부분을 명확히 분리할 수 있습니다. 이는 코드의 재사용성과 유지보수성을 높입니다.
예시: 프레임워크에서 공통적인 작업 흐름을 정의하고, 사용자가 특정 단계의 동작을 커스터마이즈할 수 있도록 할 때 자주 사용됩니다.
전략 패턴
용도: 행위를 캡슐화하고, 런타임에 행위를 선택할 수 있도록 할 때 사용합니다. 인터페이스를 통해 다양한 행동을 정의하고, 필요에 따라 실행 시점에 적절한 구현을 선택할 수 있습니다.
장점: 클래스의 행위를 변경하지 않고도 다양한 알고리즘을 사용할 수 있게 해주며, 코드의 유연성과 확장성을 높입니다.
예시: 다양한 정렬 알고리즘을 제공하고, 사용자가 필요에 따라 특정 정렬 알고리즘을 선택할 수 있도록 할 때 사용됩니다.
결론
이 두 패턴은 자바의 객체 지향 프로그래밍에서 매우 유용하며, 복잡한 시스템을 설계할 때 코드의 구조를 명확히 하고 유지보수성을 높이는 데 도움을 줍니다. 자바 개발자들이 자주 사용하는 이유는 이러한 패턴들이 코드의 모듈화를 돕고, 다양한 요구사항에 쉽게 적응할 수 있게 해주기 때문입니다.


## 루비온 레일즈에서 많이 사용하는 패턴
루비 온 레일즈(Ruby on Rails)에서는 그 자체로 많은 디자인 패턴과 아키텍처 스타일을 내장하고 있습니다. Rails는 MVC(Model-View-Controller) 아키텍처를 기반으로 하며, 이 외에도 여러 디자인 패턴이 자주 사용됩니다. 다음은 루비 온 레일즈에서 많이 사용되는 디자인 패턴들입니다:

1. MVC (Model-View-Controller)
   설명: Rails의 기본 아키텍처로, 애플리케이션을 세 가지 주요 컴포넌트로 분리합니다.
   Model: 데이터와 비즈니스 로직을 처리합니다.
   View: 사용자에게 데이터를 표시합니다.
   Controller: 사용자 입력을 처리하고 모델과 뷰를 연결합니다.
2. Active Record
   설명: Rails의 ORM(Object-Relational Mapping) 패턴으로, 데이터베이스 테이블을 클래스처럼 다루고, 각 행을 객체로 매핑합니다.
   장점: 데이터베이스 작업을 객체 지향 방식으로 처리할 수 있어 코드가 간결해집니다.
3. Observer
   설명: 모델의 상태 변화에 따라 자동으로 특정 작업을 수행할 수 있도록 해주는 패턴입니다.
   사용 예: 특정 모델의 변경 사항에 따라 이메일을 보내거나 로그를 기록할 때 사용됩니다.
4. Singleton
   설명: 애플리케이션 내에서 단 하나의 인스턴스만 존재하도록 보장하는 패턴입니다.
   사용 예: 설정 파일이나 환경 설정을 관리할 때 사용됩니다.
5. Service Object
   설명: 복잡한 비즈니스 로직을 모델이나 컨트롤러에서 분리하여 독립적인 서비스 객체로 관리하는 패턴입니다.
   장점: 코드의 모듈화와 재사용성을 높이며, 테스트가 용이해집니다.
6. Decorator
   설명: 객체의 기능을 동적으로 확장할 수 있도록 해주는 패턴입니다.
   사용 예: 뷰에서 객체의 표시 방식을 변경할 때 사용됩니다.
7. Presenter
   설명: 뷰 로직을 컨트롤러나 모델에서 분리하여 관리하는 패턴입니다.
   장점: 뷰와 관련된 로직을 깔끔하게 관리할 수 있습니다.
8. Factory
   설명: 객체 생성 로직을 캡슐화하여, 클라이언트 코드에서 객체 생성 과정을 숨기는 패턴입니다.
   사용 예: 테스트를 위한 객체 생성을 쉽게 할 때 사용됩니다.
   이러한 패턴들은 Rails의 철학인 "Convention over Configuration"과 잘 어울리며, 개발자가 생산성을 높이고 유지보수성을 개선하는 데 도움을 줍니다. Rails 커뮤니티는 이러한 패턴들을 적극적으로 활용하여 복잡한 애플리케이션을 효율적으로 관리합니다.


루비 온 레일즈에서 기본적인 MVC 패턴 외에도 개발자들이 자주 사용하는 몇 가지 디자인 패턴이 있습니다. 이러한 패턴들은 Rails의 구조와 잘 어울리며, 애플리케이션의 복잡성을 관리하는 데 도움을 줍니다.

1. Service Object
   설명: 복잡한 비즈니스 로직을 모델이나 컨트롤러에서 분리하여 독립적인 객체로 관리합니다.
   장점: 코드의 모듈화와 재사용성을 높이며, 테스트가 용이해집니다.
   사용 예: 사용자 등록과 같은 여러 단계의 비즈니스 로직을 처리할 때 사용됩니다.
2. Form Object
   설명: 폼과 관련된 로직을 캡슐화하여 모델의 책임을 줄이고, 폼 처리 로직을 관리합니다.
   장점: 복잡한 폼 데이터의 검증과 처리를 단순화합니다.
   사용 예: 여러 모델을 동시에 업데이트해야 하는 복잡한 폼을 처리할 때 사용됩니다.
3. Query Object
   설명: 복잡한 데이터베이스 쿼리를 캡슐화하여 재사용 가능하고 읽기 쉬운 방식으로 관리합니다.
   장점: 쿼리 로직을 분리하여 코드의 가독성과 유지보수성을 높입니다.
   사용 예: 복잡한 검색 조건을 처리하거나 필터링 로직을 구현할 때 사용됩니다.
4. Decorator
   설명: 객체의 기능을 동적으로 확장할 수 있도록 해주는 패턴입니다.
   장점: 기존 객체를 변경하지 않고도 새로운 기능을 추가할 수 있습니다.
   사용 예: 모델의 출력 형식을 변경하거나, 뷰에서 객체의 표시 방식을 조정할 때 사용됩니다.
5. Policy Object
   설명: 권한 검사를 캡슐화하여 관리하는 패턴입니다.
   장점: 권한 로직을 명확하게 분리하여 코드의 가독성과 보안성을 높입니다.
   사용 예: 사용자 권한에 따라 접근을 제어해야 하는 경우에 사용됩니다.
6. Presenter
   설명: 뷰 로직을 컨트롤러나 모델에서 분리하여 관리하는 패턴입니다.
   장점: 뷰와 관련된 로직을 깔끔하게 관리할 수 있습니다.
   사용 예: 복잡한 뷰 로직을 간결하게 표현할 때 사용됩니다.
7. Interactor
   설명: 하나의 작업 단위를 캡슐화하여 처리하는 패턴입니다.
   장점: 비즈니스 로직을 독립적인 객체로 관리하여 코드의 재사용성과 테스트 용이성을 높입니다.
   사용 예: 특정 작업을 수행하는 데 여러 단계가 필요한 경우에 사용됩니다.
   이러한 패턴들은 Rails 애플리케이션의 구조를 개선하고, 코드의 유지보수성을 높이는 데 매우 유용합니다. 이 패턴들을 적절히 활용하면 복잡한 비즈니스 로직을 깔끔하게 관리할 수 있습니다.