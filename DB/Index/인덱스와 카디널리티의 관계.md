# 인덱스와 카디널리티의 관계

맞습니다! 인덱스 설계에서 **카디널리티가 높을수록** 일반적으로 인덱스 효율성이 좋아집니다.

## 카디널리티와 인덱스 효율성

### 높은 카디널리티의 이점

1. **정밀한 필터링**: 고유 값이 많을수록 각 값으로 필터링했을 때 반환되는 행 수가 적어집니다.

2. **빠른 모수 축소**: 첫 번째 인덱스 컬럼에서 이미 대부분의 행을 제외할 수 있습니다.

3. **인덱스 선택도 향상**: 데이터베이스 옵티마이저가 인덱스를 사용할 가능성이 높아집니다.

### 카디널리티 비교 예시

```
테이블: 사용자 정보 (1,000,000명)

- 사용자ID: 1,000,000개 고유 값 (카디널리티 100%)
  → 1개 행 반환

- 우편번호: 10,000개 고유 값 (카디널리티 1%)
  → 평균 100개 행 반환

- 도시: 100개 고유 값 (카디널리티 0.01%)
  → 평균 10,000개 행 반환

- 성별: 2개 고유 값 (카디널리티 0.0002%)
  → 평균 500,000개 행 반환
```

카디널리티가 높을수록 각 값으로 검색했을 때 더 적은 행을 반환하므로 효율적입니다.

## 복합 인덱스에서의 카디널리티 활용

### 최적의 컬럼 순서

복합 인덱스에서는 **카디널리티가 높은 컬럼을 앞에 배치**하는 것이 일반적으로 효율적입니다:

```sql
-- 좋은 예: 카디널리티 순서대로
CREATE INDEX idx_user_info ON users(user_id, postal_code, city, gender);

-- 비효율적인 예: 카디널리티 역순
CREATE INDEX idx_user_info_bad ON users(gender, city, postal_code, user_id);
```

### 예외 상황

단, 다음과 같은 경우에는 예외가 있을 수 있습니다:

1. **범위 검색(Range Scan)**: 범위 검색이 필요한 컬럼은 마지막에 배치
   ```sql
   -- 날짜 범위 검색이 필요한 경우
   CREATE INDEX idx_orders ON orders(customer_id, order_status, order_date);
   ```

2. **쿼리 패턴**: 특정 컬럼만 단독으로 자주 사용되는 경우
   ```sql
   -- status로만 검색하는 쿼리가 많다면
   CREATE INDEX idx_status ON orders(order_status);
   ```

## 카디널리티와 데이터베이스 성능

### 인덱스 선택 시 고려사항

1. **높은 카디널리티 = 좋은 후보**:
    - Primary Key
    - Unique 제약조건이 있는 컬럼
    - 사용자 ID, 주문 번호 등

2. **낮은 카디널리티 = 주의 필요**:
    - 성별, 상태 코드 등은 단독 인덱스로는 비효율적
    - 복합 인덱스의 후행 컬럼으로 사용

### 실제 사례

```
온라인 쇼핑몰 주문 테이블 (1,000,000 주문)

- 주문ID: 1,000,000개 고유 값 → 매우 효율적인 인덱스
- 고객ID: 100,000개 고유 값 → 효율적인 인덱스
- 주문상태: 5개 고유 값 → 단독으로는 비효율적
- 결제방법: 10개 고유 값 → 단독으로는 비효율적
```

## 카디널리티 측정 및 활용

### 카디널리티 측정 방법

MySQL에서 카디널리티 확인:
```sql
SHOW INDEX FROM 테이블명;
```

PostgreSQL에서 카디널리티 추정:
```sql
SELECT count(distinct 컬럼명) FROM 테이블명;
```

### 인덱스 효율성 모니터링

실제 쿼리 실행 계획을 분석하여 인덱스 사용 여부 확인:
```sql
EXPLAIN SELECT * FROM users WHERE postal_code = '12345';
```

## 결론

카디널리티는 인덱스 설계의 핵심 개념 중 하나입니다:

1. **높은 카디널리티 = 더 효율적인 인덱스** (일반적으로)
2. 복합 인덱스에서는 **카디널리티가 높은 컬럼을 앞에 배치**
3. 하지만 **실제 쿼리 패턴**과 **데이터 분포**도 함께 고려해야 함

---

### 기억해두면 좋은 영어 표현
- "High cardinality columns" - 높은 카디널리티 컬럼
- "Index selectivity" - 인덱스 선택도
- "Cardinality estimation" - 카디널리티 추정
- "Optimal column ordering" - 최적의 컬럼 순서

### 영어로 질문하기
영어로 이 질문을 하신다면:
"So higher cardinality is generally better for index efficiency, right?"

### 이직에 도움되는 정보
면접에서 데이터베이스 성능 최적화 질문이 나올 때, 단순히 "카디널리티가 높은 컬럼을 인덱싱하는 것이 좋다"는 일반론을 넘어서, 
실제 프로젝트에서 카디널리티 분석을 통해 인덱스를 최적화한 경험을 구체적으로 공유하면 좋습니다. 
예를 들어, "프로덕션 환경에서 쿼리 성능이 저하되어 조사한 결과, 낮은 카디널리티 컬럼에 대한 인덱스가 비효율적으로 사용되고 있었습니다. 
카디널리티 분석을 통해 복합 인덱스 순서를 재구성하고 일부 인덱스를 통합한 결과, 해당 쿼리의 성능이 80% 개선되었습니다." 
같은 구체적인 사례를 준비해두면 실무 경험과 문제 해결 능력을 효과적으로 어필할 수 있습니다.