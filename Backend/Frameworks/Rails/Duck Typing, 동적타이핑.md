# Duck Typing과 동적 타이핑

## Duck Typing

**Duck Typing**은 "만약 어떤 새가 오리처럼 걷고, 오리처럼 소리내면, 그 새는 오리일 것이다"라는 격언에서 유래한 개념입니다. 이 개념은 객체의 실제 타입보다는 객체가 제공하는 메서드나 속성에 기반하여 객체를 다루는 방식입니다.

### 특징
- **행동 기반**: 객체의 타입보다는 객체가 제공하는 메서드에 초점을 맞춥니다.
- **유연성**: 특정 인터페이스를 구현하지 않아도, 필요한 메서드를 제공하면 해당 객체로 간주합니다.
- **간결성**: 인터페이스나 추상 클래스의 구현을 강제하지 않으므로 코드가 간결해집니다.

### 예시
```ruby
class Duck
  def quack
    puts "Quack!"
  end
end

class Dog
  def quack
    puts "Woof!"
  end
end

def make_it_quack(animal)
  animal.quack
end

duck = Duck.new
dog = Dog.new

make_it_quack(duck) # => "Quack!"
make_it_quack(dog)  # => "Woof!"
```

위 코드에서는 `make_it_quack` 함수가 `quack` 메서드를 가진 객체를 인자로 받습니다. 객체가 `quack` 메서드를 제공하기만 하면, 그 객체는 함수에서 사용할 수 있습니다.

## 동적 타이핑

**동적 타이핑**은 변수의 타입이 런타임에 결정되는 타입 시스템을 의미합니다. 이는 정적 타이핑과 대조되는 개념으로, 변수 선언 시 타입을 명시하지 않고, 변수에 할당된 값에 따라 타입이 결정됩니다.

### 특징
- **유연성**: 변수에 다양한 타입의 값을 할당할 수 있습니다.
- **런타임 타입 체크**: 타입 체크가 런타임에 이루어지므로, 컴파일 시점에는 타입 오류를 발견할 수 없습니다.
- **간결한 코드**: 타입 선언이 필요 없으므로 코드가 간결해집니다.

### 예시
```ruby
variable = "Hello, World!" # String 타입
puts variable

variable = 42 # Integer 타입
puts variable

variable = [1, 2, 3] # Array 타입
puts variable.inspect
```

위 코드에서 `variable`은 처음에는 문자열을, 그 다음에는 정수를, 마지막에는 배열을 할당받습니다. 변수의 타입은 할당된 값에 따라 동적으로 변경됩니다.

## 결론

- **Duck Typing**은 객체의 타입보다는 객체가 수행할 수 있는 행동(메서드)에 초점을 맞추어 프로그래밍하는 방식입니다.
- **동적 타이핑**은 변수의 타입이 런타임에 결정되며, 코드 작성 시 타입을 명시하지 않는 타입 시스템입니다.

이 두 가지 개념은 Ruby와 같은 동적 언어에서 코드의 유연성과 간결성을 높이는 데 기여합니다. 이러한 특성 덕분에 Ruby는 빠르게 프로토타입을 개발하거나 복잡한 시스템을 유연하게 설계하는 데 유리합니다.
