gRPC는 **Google Remote Procedure Call**의 약자로,   
구글에서 개발한 오픈 소스 RPC(Remote Procedure Call) 프레임워크입니다.

간단히 말해, 네트워크상의 다른 컴퓨터나 프로세스에 있는 함수를 로컬 함수처럼 호출할 수 있도록 해주는 기술이라고 생각하면 됩니다.

gRPC는 다음과 같은 장점을 가지고 있어 마이크로서비스 아키텍처 기반의 분산 시스템 개발에 많이 사용됩니다.

* **성능**: HTTP/2를 기반으로 하여 빠른 데이터 전송 속도를 제공합니다.
* **효율성**: Protocol Buffers를 사용하여 데이터를 컴팩트하게 직렬화/역직렬화하기 때문에 데이터 전송량을 줄일 수 있습니다.
* **다양한 기능**: 양방향 스트리밍, 인증, 흐름 제어, 타임아웃 등 다양한 기능을 지원합니다.
* **언어 독립성**: 다양한 프로그래밍 언어를 지원하며, 클라이언트와 서버가 서로 다른 언어로 작성될 수 있습니다.

**gRPC의 주요 구성 요소는 다음과 같습니다.**

* **Protocol Buffers**: 데이터 정의 및 직렬화/역직렬화를 위한 표준 포맷입니다.
* **gRPC 서비스**: 클라이언트가 호출할 수 있는 원격 함수를 정의합니다.
* **gRPC 클라이언트 및 서버**: 각각 클라이언트 측과 서버 측에서 gRPC 서비스를 사용하기 위한 코드입니다.

**Ruby on Rails에서 gRPC를 사용하는 방법**

Ruby on Rails에서 gRPC를 사용하려면 다음과 같은 단계를 수행해야 합니다.

1. **Protocol Buffers 파일 작성**: `.proto` 파일을 작성하여 서비스 인터페이스를 정의합니다. 이 파일에는 서비스 이름, 메서드 이름, 매개변수 및 반환 유형 등이 포함됩니다.
2. **코드 생성**: `protoc` 컴파일러를 사용하여 `.proto` 파일을 기반으로 Ruby 코드를 생성합니다. 이 코드에는 클라이언트 및 서버를 위한 코드가 포함됩니다.
3. **서버 구현**: 생성된 서버 코드를 사용하여 gRPC 서비스를 구현합니다.
4. **클라이언트 사용**: 생성된 클라이언트 코드를 사용하여 gRPC 서비스를 호출합니다.

**gRPC를 사용하면 다음과 같은 이점을 얻을 수 있습니다.**

* **성능 향상**: REST API보다 빠른 속도로 서비스를 호출할 수 있습니다.
* **코드 간결성**: Protocol Buffers를 사용하여 코드를 간결하게 작성할 수 있습니다.
* **유지보수 용이성**: 서비스 인터페이스를 `.proto` 파일에서 정의하기 때문에 유지보수가 용이합니다.
* **확장성**: 마이크로서비스 아키텍처에 적합하며, 서비스를 쉽게 추가하거나 변경할 수 있습니다.

**참고 자료**

* gRPC 공식 문서: [https://grpc.io/](https://grpc.io/)
* Ruby on Rails에서 gRPC
  사용하기: [https://alessiobussolari.medium.com/integrating-grpc-with-ruby-on-rails-2b2a203107d5](https://alessiobussolari.medium.com/integrating-grpc-with-ruby-on-rails-2b2a203107d5)
* `gruf` 라이브러리: [https://github.com/bigcommerce/gruf](https://github.com/bigcommerce/gruf)

gRPC (gRPC Remote Procedure Call)는 Google이 개발한 오픈 소스 원격 프로시저 호출 (RPC) 프레임워크입니다. 이 기술은 성능, 확장성, 효율성을 중시하는 마이크로서비스 아키텍처에
자주 사용됩니다. 다음은 gRPC의 주요 장단점입니다.

### 장점

1. **고성능**

- **HTTP/2 기반**: gRPC는 HTTP/2 프로토콜을 사용하여 멀티플렉싱, 헤더 압축, 서버 푸시 등을 지원합니다. 이는 네트워크 효율성을 높이고, 지연 시간을 줄이는 데 도움이 됩니다.
- **바이너리 프로토콜 버퍼**: gRPC는 Protocol Buffers (protobuf)라는 바이너리 직렬화 방식을 사용하여 데이터를 직렬화합니다. 이는 JSON보다 더 빠르고, 더 작은 메시지 크기를
  제공합니다.

2. **다양한 언어 지원**

- gRPC는 다양한 프로그래밍 언어 (예: Java, C++, Python, Go, Node.js 등)를 지원하여 여러 언어로 작성된 마이크로서비스 간의 상호 운용성을 보장합니다.

3. **자동 코드 생성**

- Protocol Buffers를 사용하여 서비스 정의 파일(.proto)을 작성하면, gRPC는 이를 기반으로 클라이언트 및 서버 스텁 코드를 자동으로 생성합니다. 이는 개발 생산성을 높이고, 일관된 API
  계약을 유지하는 데 도움이 됩니다.

4. **양방향 스트리밍**

- gRPC는 클라이언트-서버 간의 양방향 스트리밍을 지원하여, 실시간 데이터 전송 및 복잡한 스트리밍 워크플로우를 구현할 수 있습니다.

5. **강력한 타입 시스템**

- Protocol Buffers는 강력한 타입 시스템을 제공하여, 데이터 무결성을 유지하고, 직렬화/역직렬화 시 타입 안전성을 보장합니다.

6. **부가 기능**

- **로드 밸런싱, 추적, 모니터링**: gRPC는 다양한 로드 밸런싱 전략, 분산 추적, 모니터링 도구와 쉽게 통합할 수 있는 기능을 제공합니다.

### 단점

1. **복잡성**

- **초기 설정**: gRPC는 설정 및 학습 곡선이 있을 수 있습니다. 특히 HTTP/1.1 기반의 RESTful API에 익숙한 개발자에게는 새로운 개념과 도구 (예: .proto 파일, Protocol
  Buffers 등)를 배우는 것이 필요합니다.
- **디버깅**: 바이너리 형식의 메시지를 사용하기 때문에, JSON과 같은 텍스트 기반의 직렬화 형식에 비해 디버깅이 어렵습니다.

2. **제한된 브라우저 지원**

- HTTP/2를 기반으로 하기 때문에, 현재 gRPC는 브라우저에서 직접 사용할 수 없습니다. 이를 해결하기 위해 gRPC-Web을 사용할 수 있지만, 이는 추가적인 설정이 필요합니다.

3. **낮은 유연성**

- gRPC는 엄격한 API 계약을 요구하며, 이는 일부 상황에서 유연성을 떨어뜨릴 수 있습니다. 예를 들어, 빈번한 API 변경이 필요한 경우, 서비스 정의 파일과 스텁 코드의 재생성이 필요합니다.

4. **도구 생태계**

- RESTful API에 비해 gRPC는 상대적으로 도구와 라이브러리가 제한적입니다. 특히, RESTful API 테스트를 위한 Postman과 같은 도구에 비해 gRPC 테스트 도구는 아직 성숙하지 않았습니다.

5. **서비스 디스커버리 및 로드 밸런싱**

- gRPC는 서비스 디스커버리 및 로드 밸런싱 기능을 기본적으로 제공하지 않습니다. 이를 위해 별도의 도구 (예: Consul, Kubernetes)와 통합해야 합니다.

### 결론

gRPC는 고성능, 다중 언어 지원, 자동 코드 생성, 스트리밍 기능 등 많은 장점을 제공하여 마이크로서비스 아키텍처에 적합한 선택입니다. 그러나 초기 설정의 복잡성, 브라우저 지원 문제, 도구의 제한성 등 단점도
고려해야 합니다. 프로젝트의 요구 사항과 팀의 기술 스택에 따라 gRPC를 선택할지 여부를 신중하게 결정해야 합니다.

## RPC (Remote Procedure Call)가 성능이 좋다고 평가받는 이유

### 1. **직접적인 메소드 호출**

RPC는 클라이언트가 원격 서버의 메소드를 직접 호출하는 방식으로 작동합니다. 이는 로컬에서 메소드를 호출하는 것과 매우 유사한 형태를 취하며, 프로토콜의 오버헤드를 최소화할 수 있습니다. 결과적으로, 호출 시간이
단축되고 효율성이 높아집니다.

### 2. **효율적인 데이터 직렬화**

많은 RPC 프레임워크는 데이터 직렬화와 역직렬화에 최적화된 형식을 사용합니다. 예를 들어, gRPC는 프로토콜 버퍼(Protocol Buffers, Protobuf)를 사용하여 데이터를 직렬화합니다.
Protobuf는 가볍고, 빠르며, 데이터 크기를 최소화할 수 있는 바이너리 형식을 사용합니다. 이러한 효율적인 직렬화는 네트워크 대역폭을 줄이고, 전송 속도를 높입니다.

### 3. **단일 통신 채널**

RPC는 클라이언트와 서버 간의 단일 통신 채널을 통해 데이터를 교환합니다. HTTP/2를 사용하는 gRPC와 같은 현대적인 RPC 프레임워크는 멀티플렉싱, 헤더 압축, 지속적인 연결 등을 지원하여 네트워크 효율성을
극대화합니다. 이는 특히 다수의 요청과 응답이 발생하는 시나리오에서 성능 향상에 기여합니다.

### 4. **보다 낮은 프로토콜 오버헤드**

RPC는 보통 REST API보다 낮은 프로토콜 오버헤드를 갖습니다. REST API는 HTTP 프로토콜을 사용하며, 각 요청과 응답에 대해 추가적인 HTTP 헤더와 상태 코드 등이 필요합니다. 반면, RPC는 더
간결한 프로토콜을 사용하여 통신 오버헤드를 줄입니다.

### 5. **비동기 호출과 스트리밍 지원**

gRPC와 같은 RPC 프레임워크는 비동기 호출과 양방향 스트리밍을 지원합니다. 이는 클라이언트와 서버 간의 비동기적 데이터 교환을 가능하게 하며, 시스템 자원의 효율적인 사용과 성능 향상을 도모합니다.

### 6. **서버 측 스트리밍과 클라이언트 측 스트리밍**

gRPC는 서버 측 스트리밍과 클라이언트 측 스트리밍을 지원하여, 큰 데이터나 연속적인 데이터를 효율적으로 전송할 수 있습니다. 이는 대규모 데이터 처리 및 실시간 데이터 처리에 있어 성능 이점을 제공합니다.

### 7. **코드 생성 및 강력한 타입 검사**

RPC 프레임워크는 종종 코드 생성 도구를 제공하여 클라이언트와 서버 간의 인터페이스 코드를 자동으로 생성합니다. 이는 개발자 오류를 줄이고, 강력한 타입 검사를 통해 런타임 오류를 방지하며, 성능 향상에
기여합니다.

### RPC와 REST API 비교

- **프로토콜**: RPC는 다양한 프로토콜(gRPC, Thrift 등)을 사용하며, REST API는 HTTP를 사용합니다.
- **직렬화 형식**: RPC는 바이너리 직렬화 형식(Protobuf 등)을 사용하여 데이터 크기를 최소화하고, REST API는 일반적으로 텍스트 형식(JSON, XML 등)을 사용합니다.
- **오버헤드**: RPC는 더 낮은 프로토콜 오버헤드를 가지며, REST API는 HTTP의 오버헤드를 포함합니다.
- **성능**: RPC는 일반적으로 더 높은 성능을 제공하며, REST API는 더 높은 가독성과 유연성을 제공합니다.
- **사용 용도**: RPC는 성능이 중요한 내부 서비스 간 통신에 적합하며, REST API는 다양한 클라이언트(브라우저, 모바일 앱 등)를 지원하는 공용 API에 적합합니다.

결론적으로, RPC는 성능 최적화에 중점을 두고 설계된 기술로, 분산 시스템에서 고성능 통신을 필요로 하는 시나리오에 적합합니다. 반면, REST API는 더 높은 유연성과 사용 용이성을 제공하여 다양한 클라이언트를
지원하는 데 유리합니다.