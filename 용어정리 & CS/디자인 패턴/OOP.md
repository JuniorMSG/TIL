<!-- TOC -->
  * [프로그래밍 패러다임](#프로그래밍-패러다임)
    * [왜 사용하는가?](#왜-사용하는가)
    * [비용이란?](#비용이란)
    * [응집도(cohesion)와 결합도(coupling)](#응집도cohesion와-결합도coupling)
      * [응집도(cohesion)](#응집도cohesion)
      * [결합도(coupling)](#결합도coupling)
    * [개발 시간 증가 이유](#개발-시간-증가-이유)
    * [코드를 분리하자](#코드를-분리하자)
      * [1. 패턴 적용](#1-패턴-적용)
      * [2. 계산 기능 분리](#2-계산-기능-분리)
      * [3. 외부 연동 분리](#3-외부-연동-분리)
      * [4. 연속적인 if-else는 추상화를 고민해본다.](#4-연속적인-if-else는-추상화를-고민해본다)
    * [Reference](#reference)
  * [객체 지향 프로그래밍이란 무엇인가?](#객체-지향-프로그래밍이란-무엇인가)
    * [특징](#특징)
    * [기능이란?](#기능이란)
      * [EX) 회원가입 기능](#ex-회원가입-기능)
      * [기능 명세](#기능-명세)
    * [큰 클래스와 메서드](#큰-클래스와-메서드)
    * [추상 클래스 (Abstract Class)](#추상-클래스-abstract-class)
    * [구상클래스 (Concrete Class)](#구상클래스-concrete-class)
    * [인터페이스 (Interface)](#인터페이스-interface)
    * [Generlization(일반화)](#generlization일반화)
    * [의존 (Dependency)](#의존-dependency)
      * [순환 의존](#순환-의존)
    * [의존 주입 (Dependency Injection)](#의존-주입-dependency-injection)
      * [장점](#장점)
  * [객체지향의 특성](#객체지향의-특성)
    * [추상화](#추상화)
      * [특징](#특징-)
      * [유연함](#유연함)
      * [언제 해야하는가?](#언제-해야하는가)
      * [서로 다른 구현 추상화](#서로-다른-구현-추상화-)
      * [타입 추상화](#타입-추상화-)
    * [캡슐화](#캡슐화)
      * [특징](#특징--1)
    * [상속성](#상속성)
      * [단점](#단점)
      * [조립 (Composition)](#조립-composition)
    * [상속보다는 조립(Composition over inheritance)](#상속보다는-조립composition-over-inheritance)
    * [다형성 (polymorphism)](#다형성-polymorphism)
      * [오버로딩](#오버로딩)
      * [오버라이딩](#오버라이딩-)
  * [객체지향 5대 원칙](#객체지향-5대-원칙)
    * [1. 단일 책임 원칙 (Single Responsibility Principle)](#1-단일-책임-원칙-single-responsibility-principle)
    * [2. 개방 폐쇄의 원칙 (Oepn-Closed Principle)](#2-개방-폐쇄의-원칙-oepn-closed-principle)
    * [3. 리스코프 치환 원칙 (Liskov Subsititution Principle)](#3-리스코프-치환-원칙-liskov-subsititution-principle)
    * [4. 의존 역전 원칙 (Dependency Inversion Principle)](#4-의존-역전-원칙-dependency-inversion-principle)
    * [5. 인터페이스 분리 원칙 (Interface Segregation Principle)](#5-인터페이스-분리-원칙-interface-segregation-principle)
  * [클래스 다이어그램](#클래스-다이어그램)
    * [연관 관계 (association)](#연관-관계-association)
    * [집합 관계 (composition, aggregation)](#집합-관계-composition-aggregation)
    * [의존 관계 (dependency)](#의존-관계-dependency)
    * [일반화 관계 (generalization)](#일반화-관계-generalization)
    * [실체화 관계 ( realization )](#실체화-관계--realization-)
    * [접근 제어자 표시](#접근-제어자-표시)
<!-- TOC -->

## 프로그래밍 패러다임
    프로그래밍 패러다임은 프로그래머에게 프로그래밍의 관점을 갖게 해 주고, 결정하는 역할을 한다
    객체지향 프로그래밍은 프로그래머들이 프로그램을 상호작용하는 객체들의 집합으로 볼 수 있게 하고
    함수형 프로그래밍은 상태값을 지니지 않는 함수값들의 연속으로 생각할 수 있게 한다.

### 왜 사용하는가?
    여러가지 프로그래밍 패러타임들은 결국 비용을 줄이고 쉽게 수정하기 위해서가 아닐까?
    1. 소스를 쉽게 파악하고
    2. 수정에 대한 사이드 이펙트를 줄이고
    3. 테스트를 자동화 하고
    4. 오류를 줄이고.

### 비용이란?
    대충 이런 비용이 있다고 본다.

    1. 코드를 파악하는데 드는 시간
        - 해당 코드를 수정 할 때 생기는 사이드 이펙트 파악

    2. 코드를 수정하는데 드는 시간
        - 실제 수정 시간
        - 테스트 시간

![img_3](https://github.com/user-attachments/assets/8478198b-dade-4a9c-80ff-654c3f65c265)

### 응집도(cohesion)와 결합도(coupling)
- 잘 만들어진 소프트웨어는 응집도는 높고 결합도는 낮아야 함

#### 응집도(cohesion)
- 하나의 모듈, 객체 내부의 요소들간의 연관성
- 하나의 책임/기능을 구현하는 하나의 객체는 높은 응집도를 가짐

#### 결합도(coupling)
- 객체 상호관의 연관 관계
- 결합도가 높으면 하나의 객체를 수정할 때 다른 객체도 수정해야 함
- 상속은 클래스간의 결합도를 높히기 때문에 조심
- 느슨한 결합을 위해 인터페이스 등을 사용하게됨!

### 개발 시간 증가 이유
    1. 코드 구조가 길어지고 복잡해짐
        - if-else는 복잡도를 배로 증가
        - if-else가 많을수록 진척이 더딤 (신중해져야함)
    2. 관련 코드가 여러 곳에 분산됨
    3. 코드 가독성과 분석 속도가 저하됨
        - 코드 추가에 따른 노동 시간 증가
        - 실수하기 쉽고 이로 인한 불필요한 디버깅 시간 증가 

### 코드를 분리하자
    책임/기능에 따라 알맞게 역할 분리가 잘 되면 테스트가 용이해진다.

    역할 분리 방법
        1. 패턴 적용
        2. 계산 기능 분리
        3. 외부 연동 분리
        4. 조건별 분기는 추상화
#### 1. 패턴 적용
    MVC - 컨트롤러, 서비스 ,DAO
    AOP - Aspect(공통 기능)
    도메인 - 엔티티, 밸류, repository, domain service
    GoF - 팩토리 ,빌더, 전략, 템플릿 메서드, 프록시/데코레이터 등 

#### 2. 계산 기능 분리
    맴버등급에 따라서 할인율이 달라진다고 치면..
    계산을 메인 로직에서 하는게 아닌 새로운 클래스로 분리하고 
    호출하여 사용한다.

#### 3. 외부 연동 분리
    네트워크, 메시징, 파일 등 연동 처리 코드를 분리한다.

#### 4. 연속적인 if-else는 추상화를 고민해본다.
    역할을 분리할때는 의도가 잘 드러나는 이름을 사용해야 한다.
    점심 메뉴를 추천해주는 기능 분리시
    RecommendLunchService > lunchDataService

### Reference
[위키백과](https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%ED%8C%A8%EB%9F%AC%EB%8B%A4%EC%9E%84)

## 객체 지향 프로그래밍이란 무엇인가?
    객체 지향 프로그래밍 이전의 프로그래밍 패러다임을 살펴보면, 중심이 컴퓨터에 있었다. 컴퓨터가 사고하는대로 프로그래밍을 하는 것이다. 
    객체지향 프로그래밍이란 인간 중심적 프로그래밍 패러다임이라고 할 수 있다. 
    현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 
    애플리케이션에 필요한 특징들을 뽑아와 프로그래밍 하는 것이다.

### 특징
    객체는 제공하는 기능으로 정의
    내부적으로 가진 필드(데이터)로 정의하지 않음

### 기능이란?
    기능은 곧 책임이다.
    기능은 하위 기능으로 분해가 가능하다.
    기능을 분리하고, 각 객체에게 분리한 각 기능을 알맞게 분배한다.

#### EX) 회원가입 기능
![img](https://github.com/user-attachments/assets/4005a723-f48b-4c98-a9b8-4da58761d775)
![img_1](https://github.com/user-attachments/assets/0a268466-81e0-4c38-a3d8-be712698feee)

#### 기능 명세
- 메서드를 이용해서 기능 명세
    - 이름, 파라미터, 결과로 구성됨

- 객체는 제공하는 기능으로 정의한다.
  - EX : 회원 객체
    - 암호 변경하기 기능
    - 자기소개 변경하기 기능


### 큰 클래스와 메서드
    클래스나 메서드가 커지면 절차 지향과 똑같은 문제가 발생한다.
    큰 클래스 -> 많은 필드를 많은 메서드가 공유한다.
    큰 메서드 -> 많은 변수를 많은 코드가 공유한다.
    여러 기능이 한 클래스/메서드에 섞여 있을 가능성이 늘어난다.

### 추상 클래스 (Abstract Class)
* 추상 클래스(abstract class)는 하나 이상의 추상 메소드(abstract method)를 포함하는 클래스이다.
* 추상 메소드는 선언만 있고, 선언부에 ‘abstract’ 라는 키워드를 붙인다.
* 추상 메소드가 포함되었다면 클래스도 추상 클래스이므로 클래스명 앞에 ‘abstract’ 키워드를 붙여야 한다.
* 추상 클래스는 다른 하위 클래스를 상속하기 위한 용도이다.
* 추상 클래스에서 매개변수 생성자 메소드가 필요한 이유는 추상 클래스는 하위 클래스에 상속을 목적으로 만들어진
클래스이기때문에, 하위 클래스에서 상위 클래스에 만들어둔 매개변수 생성자 메소드를 통하여 인스턴스 변수의 값을
초기화하기 때문이다.
* 추상 클래스는 미완성클래스이기때문에 인스턴스를 생성할 수 없다.

### 구상클래스 (Concrete Class)
* new 연산자를 사용하여 인스턴스를 생성할 수 있는 클래스를 Concrete(구상) 클래스라고 한다.
* 미완성클래스인 추상클래스에 정의된 기능을 구현하는 클래스이다.

### 인터페이스 (Interface)
* 클래스의 공통된 기능을 정리한 명세서이다.
* 모든 기능을 추상화로 정의만 하고 구현은 하지 않은것이다.(100% 추상 메소드)
* 추상클래스는 클래스이기때문에 상속을 한번만 하며, 상속을 통해 서브클래스에서 구현을완성하기 위한 클래스이지만, 
* 인터페이스도 구상클래스를 생성하여 상속을 하는것까지는 동일하지만 인터페이스의 특성상 다중상속도 가능하다는

### Generlization(일반화)
    슈퍼클래스와 서브클래스간의 Inheritance(상속) 관계를 나타낸다. 
    여기서 Generalization이란 서브 클래스가 주체가되어 서브 클래스를 슈퍼 클래스로 Generalization 하는 것을 말하고 
    반대의 개념은 슈퍼 클래스를 서브 클래스로 Specialize(구체화)하는 것이다. 
    상속은 슈퍼 클래스의 필드 및 메소드를 사용하며 구체화하여 필드 및 메소드를 추가하거나 필요에따라 
    메소드를 overriding(오버라이딩)하여 메소드 재정의를 한다. 또는 슈퍼클래스가 추상클래스인 경우에는 인터페이스의
    메소드 구현과 같이 추상 메소드를 반드시 오버라이딩 하여 구현해야한다.

### 의존 (Dependency)
    - 코드에서 두 모듈 간의 연결을 의미한다
    - 의존하는 대상은 적을수록 좋다. 
    - 의존은 변경이 전파될 가능성을 의미한다.

    ex1) 호출 메서드 파라미터 변경
    ex2) 호출하는 메서드가 발생할 수 있는 익셉션 타입 추가 
    
    * 팩토리, 빌더
    * 의존 주입 (Dependency Injection)
    * 서비스 로케이터(Service Locator)

#### 순환 의존
    변경이 연쇄 전파 되므로 사용하면 한다.
    클래스, 패키지, 모듈 등 모든 수준에서 순환 의존 없도록 해야한다.

### 의존 주입 (Dependency Injection)
    외부에서 의존 객체를 주입한다.
    생성자나 메서드를 이용하여 주입한다.
    의존 객체는 주입받도록 코드를 작성하는 습관을 들여보자
    Spring Beans , Spring ApplicationContext
![img_2](https://github.com/user-attachments/assets/e5eae699-a942-44cd-b958-4e992445d88d)

#### 장점
    의존 대상이 바뀌면 설정만 변경하면 된다.
    의존하는 객체 없이 대역 객체를 사용해서 테스트 가능
        - DB 없이 DB와 연동하는 기능 테스트가 가능하다.
    대역 객체를 사용해서 테스트 가능하다.


## 객체지향의 특성
    추상화 (Abstraction)
    캡슐화 (Encapsulation)
    상속성, 재사용 (Inheritance)
    다형성 (polymorphism)
    
### 추상화
    데이터나 프로세스 등을 의미가 비슷한 개념이나 의미 있는 표현으로 정의하는 과정
    여러 구현의 공통점을 상위 타입으로 도출하는 것이다.
    구현을 한 이유가 무엇 때문인지 잘 생각해야 함.

#### 특징 
- 코드의 유연성을 높혀준다.
- 어떤 영역에서 필요로 하는 속성이나 기능을 추출하는 작업
- 데이터 구조, 표현방법에 대한 추상화
- 처리 과정에 대한 추상화

#### 유연함
    모듈간의 결합도를 낮추고 응집성을 높힌다.
    본질이랑 상관 없는 기능 수정에 주요 기능이 수정 되는 경우를 막을 수 있다.
    ex) 주문 취소라는 메인 기능이 구현된 상태에서
        메일 보내는 기능이 추가되는 기능이 추가되며 주요 기능에 대한 코드 수정이 생긴다.
    
#### 언제 해야하는가?
    추상화 -> 추상 타입 증가 -> 복잡도 증가
    아직 존재하지 않는 기능에 대한 이른 추상화는 주의
    잘못된 추상화 가능성, 복잡도만 증가한다.
    실제 변경 & 확장이 발생할 때 추상화를 시도한다.

 
#### 서로 다른 구현 추상화  
![구현 추상화](https://user-images.githubusercontent.com/22822369/184500099-1d428a9c-a634-4a1e-a9cc-947d9e36ac71.png)

#### 타입 추상화 
    여러 구현 클래스를 대표하는 상위 타입 도출
    흔히 인터페이스 타입으로 추상화
    추상화 타입과 구현은 타입 상속으로 연결
![타입 추상화](https://user-images.githubusercontent.com/22822369/184500110-d51514f9-7d55-4eab-99c7-8b00b6c27ed4.png)


### 캡슐화
    내부 구현을 감춰서 내부 구현 변경에 따른 외부 영향을 최소화 하는 방법이다.
#### 특징    
- 데이터를 감싸서 외부에서 사용 가능한 부분만을 제공 (Infomation hiding)
- 호출자는 코드의 세부적인 사항을 알 필요가 없다.
![img_4](https://github.com/user-attachments/assets/c8ffb295-564b-4b81-9b62-e386a8ba9f77)

### 상속성
- 일반적인(general) 개념의 객체에서 보다 구체적인(specific) 개념의 객체의 관계를 표현
- 상속관계의 클래스는 상위 클래스의 타입을 내포함
- 상위 클래스의 속성과 기능을 하위 클래스에서 사용하거나 재정의 할 수 있음

#### 단점
* 상위 클래스 변경 어려움
    * 변경이 하위 클래스에 영향을 준다.
* 클래스 증가
* 상속 오용

#### 조립 (Composition)
    여러 객체를 묶어서 더 복잡한 기능을 제공
    필드로 다른 객체를 참조하는 방식, 필요 시점에 생성/구현

### 상속보다는 조립(Composition over inheritance)
    상속하기에 앞서 조립으로 풀 수 없는지 검토
    진짜 하위 타입인 경우에만 상속을 사용해라.
    


### 다형성 (polymorphism)
    여러 (poly) 모습(morph)을 갖는 것  
    객체 지향에서는 한 객체가 여러 타입을 갖는 것  
    한 객체가 여러 타입의 기능을 제공   
    타입 상속으로 다형성 구현
- 같은 메세지, 같은 구현에 대해 각 객체가 다른 표현과 결과를 나타내는 것
- 클래스의 상속, 인터페이스의 구현 시에 각각의 다른 구현을 가진 클래스들이 상위 타입으로 업캐스팅이 되고
 이 때, 각 클래스에서 오버라이딩한 메서드가 존재하는 경우 같은 상위 타입으로 선언된다 하더라도 각기 다른 인스턴스의 메서드가 호출되는것

#### 오버로딩
    같은 이름의 함수(메서드)를 여러개 정의하고, 매개변수의 유형과 개수를 다르게하여 다양한 유형의 호출에 응답
#### 오버라이딩 
    상위 클래스가 가지고 있는 멤버변수가 하위 클래스로 상속되는 것처럼 상위 클래스가 가지고 있는 메서드도 하위 클래스로 상속되어 하위 클래스에 사용할 수 있습니다. 
    또한, 하위 클래스에서 메서드를 재정의해서도 사용할 수 있습니다. 
    쉽게 말해 메서드의 이름이 서로 같고, 매개변수가 같고, 반환형이 같을 경우에 상속받은 메서드를 덮어쓴다고 생각하시면 됩니다. 


## 객체지향 5대 원칙
    SOLID 라고 불린다.
    S : 단일 책임 원칙 (Single Responsibility Principle)
    O : 개방 폐쇄의 원칙 (Oepn-Closed Principle)
    L : 리스코프 치환 원칙 (Liskov Subsititution Principle)
    I : 인터페이스 분리 원칙 (Interface Segregation Principle)
    D : 의존 역전 원칙 (Dependency Inversion Principle)

### 1. 단일 책임 원칙 (Single Responsibility Principle)
    DAO는 DB에 연결해서 데이터를 가져오는 역할만 하도록 만들어라 안에 이상한거 만들어서 다른 이유로 수정 되면 안된다.
- 하나의 클래스는 하나의 기능만을 구현하도록 한다. 즉, 어떤 클래스를 변경하는 이유는 하나이어야 한다
- 한 클래스에서 여러 기능을 제공하게 되면 유지보수가 어려움 

### 2. 개방 폐쇄의 원칙 (Oepn-Closed Principle)
    JDBC - 다양한 데이터베이스 (Oracle, Mysql, Etc ... ) JDBC는 interface, connection, statement등에 대한 인터페이스를 
    서드파티사 (Oracle, Mysql, Etc ... )에서 구현하게 된다.
- 객체 자신의 수정에 대해서는 유연하고, 다른 클래스가 수정될 때는 영향을 받지 않는다.
- 인터페이스나 추상클래스를 통해 핸들링함
- 예) 자바 JDBC, I/O Stream, 

### 3. 리스코프 치환 원칙 (Liskov Subsititution Principle)
- 하위 클래스는 항상 상위 클래스로 교체 될 수 있어야 한다.
- 즉, 상위 클래스에 제공되는 여러 기능은 하위 클래스가 모두 사용가능 해야 한다.
- IS-A 관게, "is a kind of" 관계 

### 4. 의존 역전 원칙 (Dependency Inversion Principle)
    주문을 하는 클래스(A)가 있다. 주문을 받는아서 배송하는 클래스(B)가 있다.
    A클래스에선 배송 방법을 선택해야 한다.
    B클래스는 다양한 배송(트럭, 비행기, 배, 오토바이) 등을 제공한다.
    해당 경우에 A클래스는 B클래스의 운송 수단을 알 필요가 없다.(추상적인 개념으로 배송만 중요할 뿐)
    B클래스 배송방법을 내부적으로 알아서 잘 관리하면 된다.
- 의존 관계는 구체적인 것보다는 추상적인 것에 의존한다.
- 구체적인 것은 이미 구현이 되어있고 변하기 쉬운것
- 추상적인 것은 인터페이스나 추상 클래스(상위 클래스)

### 5. 인터페이스 분리 원칙 (Interface Segregation Principle)
- 제공하는 기능에 대한 인터페이스에만 종속적이어야 함
- 만약 하나의 객체가 여러 기능을 제공해야 한다면 ( 단일 책임 원칙에 위배 ) 이때 클라이언트가 사용할 수 있는 여러 인터페이스로 분리하여
  제공하면 클라이언트가 사용하지 않는 기능에 종속적이지 않을 수 있음


## 클래스 다이어그램
- 객체 지향 프로그래밍에서 여러 클래스 상호관의 혐력 관계를 나타내는 Diagram
- 클래스 간의 관계를 설계 할때 유용함


### 연관 관계 (association)
- 클래스 상호 간에 서로 연관되어 있음을 나타냄
- 단방향 연관관계의 경우는 화살표(->)로 표시한다.
- 양방향 연관관계는 직선(-)으로 표시한다.
- 클래스간의 연관된 개체의 수를 표현해야 하는 경우에는 선의 끝쪽에 다중성(multiplicity)를 나타낸다.
![img.png](https://user-images.githubusercontent.com/22822369/184500129-ea36f790-d1ba-44e0-9420-36bf7c435aed.png)
```java
public class Student {
	int studentID;
	String studentName;
	ArrayList<Subject> subjectList;
}
```
![img.png](https://user-images.githubusercontent.com/22822369/184500133-70f73ec9-117e-4448-bdc8-25d67d45dce8.png)


### 집합 관계 (composition, aggregation)

- 연관관계의 특별한 경우
- 클래스간의 포함관계를 나타냄
- 전체 객체와 부분 객체의 인스턴스 생존 주기( life time ) 에 따라 두가지로 구분할 수 있음

**집약 관계**

- 클래스 다이어그램에 빈 마름모로 표시
- 전체 객체와 부분 객체의 라이프 타임이 독립적 즉, 포함하는 객체(전체 객체)가 사라져도 포함된 객체 (부분 객체)는 사라지지 않음
- 공유하는 리소스가 해당됨
- 전체 객체가 생성될 때 매개 변수로 전달 받음

**합성 관계**

- 클래스 다이어그램에 채워진 마름모로 표시
- 전체 객체의 라이프 타임에 부분객체가 종속됨. 전체 객체가 사라지면 부분 객체도 사라짐
- 주로 멤버 변수로 선언하여 사용
- 전체 객체의 생성자에서 부분 객체를 생성함

### 의존 관계 (dependency)

- 연관 관계 보다는 짧은 life time
- 프로그램 내에서는 참조 변수가 매개변수나 지역 변수로 구현

```
class Student {

    int money;
...
    public void takeBus(Bus bus) {
		  bus.take(1000);
		  this.money -= 1000;
		  
	 }
	    
	public void takeSubway(Subway subway) {
		  subway.take(1500);
		  this.money -= 1500;
	 }
}
```   
![img.png](https://user-images.githubusercontent.com/22822369/184500142-c23e4695-39b5-4c9f-a33d-90b10e89ad3e.png)



### 일반화 관계 (generalization)
- 객체 지향에서 상속을 표현할 때
- 일반적인 클래스(상위 클래스)를 보다 구체적인 클래스(하위 클래스)가 상속함  
![img.png](https://user-images.githubusercontent.com/22822369/184500153-e5a116c8-a7f1-460f-9749-21aa7694e6e3.png)


### 실체화 관계 ( realization )

- 기능이 선언된 인터페이스를 구현하는 클래스는 선언된 기능을 구현할 책임이 있음
- 여러 클래스가 하나의 인터페이스를 구현함으로써 다형성을 제공함  
![img.png](https://user-images.githubusercontent.com/22822369/184500159-06b3627a-6dae-4aaa-8675-2b6947c956d4.png)


### 접근 제어자 표시
| 접근제어자 | 표시 | 설명 |
| ------ | ------ |------ |
| public | + | 내부, 외부 모드 접근 가능 |
| protected | * | 같은 패키지나 상속관계의 클래스만 접근 가능 |
| default | ~ | 같은 패키지만 접근 가능 |
| private | - | 같은 클래스 내부에서만 접근 가능 |


