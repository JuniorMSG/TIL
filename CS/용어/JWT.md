## JWT의 기본 개념

JWT(JSON Web Token)는 당사자 간에 정보를 안전하게 전송하기 위한 개방형 표준(RFC 7519)입니다. 
JWT는 자체 포함적(self-contained) 방식으로 정보를 안전하게 전송할 수 있는 컴팩트한 토큰 형식을 제공합니다.

## JWT의 구조적 특징

JWT는 세 부분으로 구성되며, 각 부분은 점(.)으로 구분됩니다:

### 1. 헤더(Header)
- **목적**: 토큰 유형과 사용된 서명 알고리즘을 지정
- **주요 속성**:
    - `typ`: 토큰 유형(일반적으로 "JWT")
    - `alg`: 서명 알고리즘(예: HS256, RS256, ES256 등)
- **인코딩**: Base64Url로 인코딩됨

### 2. 페이로드(Payload)
- **목적**: 토큰에 담을 실제 데이터(클레임)를 포함
- **클레임 유형**:
    - **등록된 클레임(Registered Claims)**: IANA JWT 클레임 레지스트리에 등록된 표준 클레임
        - `iss` (발행자): 토큰 발행 주체
        - `sub` (주제): 토큰 주제(일반적으로 사용자 ID)
        - `aud` (대상): 토큰 수신자
        - `exp` (만료 시간): 토큰 만료 시간(Unix 타임스탬프)
        - `nbf` (Not Before): 토큰이 유효해지는 시작 시간
        - `iat` (발행 시간): 토큰 발행 시간
        - `jti` (JWT ID): 토큰의 고유 식별자
    - **공개 클레임(Public Claims)**: 충돌 방지를 위해 URI 형식으로 정의된 클레임
    - **비공개 클레임(Private Claims)**: 당사자 간에 합의된 사용자 정의 클레임
- **인코딩**: Base64Url로 인코딩됨
- **중요 사항**: 페이로드는 암호화되지 않고 단순히 인코딩만 되므로 민감한 정보는 포함하지 않아야 함

### 3. 서명(Signature)
- **목적**: 토큰의 무결성 검증 및 발행자 인증
- **생성 방식**: 인코딩된 헤더와 페이로드를 비밀키와 함께 지정된 알고리즘으로 서명
- **서명 알고리즘**:
    - **HMAC**: 대칭 키 알고리즘(HS256, HS384, HS512)
    - **RSA**: 비대칭 키 알고리즘(RS256, RS384, RS512)
    - **ECDSA**: 타원 곡선 디지털 서명 알고리즘(ES256, ES384, ES512)
    - **EdDSA**: Edwards-curve 디지털 서명 알고리즘(EdDSA)
- **보안 강도**: 알고리즘과 키 길이에 따라 달라짐

## JWT의 작동 원리

1. **토큰 생성 과정**:
    - 서버는 헤더와 페이로드를 생성하고 Base64Url로 인코딩
    - 인코딩된 헤더와 페이로드를 비밀키로 서명하여 서명 생성
    - 헤더, 페이로드, 서명을 점(.)으로 연결하여 JWT 생성

2. **토큰 검증 과정**:
    - 클라이언트로부터 받은 JWT를 점(.)을 기준으로 헤더, 페이로드, 서명으로 분리
    - 헤더와 페이로드를 사용하여 동일한 알고리즘과 비밀키로 서명 재계산
    - 재계산된 서명과 받은 서명을 비교하여 일치 여부 확인
    - 토큰의 만료 시간(exp) 등 추가 검증 수행

## JWT의 기술적 특성

### 장점

1. **상태 비저장(Stateless)**:
    - 서버에 세션 상태를 저장할 필요가 없음
    - 수평적 확장성이 우수하여 마이크로서비스 아키텍처에 적합
    - 서버 간 인증 정보 공유가 용이

2. **자체 포함적(Self-contained)**:
    - 필요한 모든 정보를 토큰 자체에 포함
    - 데이터베이스 조회 없이 사용자 정보 접근 가능
    - 네트워크 지연 감소 및 성능 향상

3. **교차 도메인 지원**:
    - CORS(Cross-Origin Resource Sharing) 문제 해결에 도움
    - 다양한 서비스 간 인증 정보 공유 용이

4. **다양한 서명 알고리즘 지원**:
    - 대칭 키(HMAC) 및 비대칭 키(RSA, ECDSA) 알고리즘 지원
    - 보안 요구사항에 따라 적절한 알고리즘 선택 가능

### 단점

1. **토큰 크기**:
    - 세션 ID에 비해 크기가 큼(특히 많은 클레임 포함 시)
    - 모든 요청에 포함되므로 대역폭 사용량 증가

2. **토큰 무효화의 어려움**:
    - 기본적으로 발급된 토큰은 만료 시간까지 유효
    - 명시적 무효화를 위해서는 블랙리스트 등 추가 메커니즘 필요

3. **보안 위험**:
    - XSS 공격에 취약할 수 있음(토큰이 JavaScript에서 접근 가능한 경우)
    - 페이로드는 암호화되지 않고 단순히 인코딩만 되므로 민감한 정보 노출 위험

4. **키 관리 복잡성**:
    - 비대칭 키 사용 시 공개 키와 개인 키 관리 필요
    - 키 순환(rotation) 및 보안 저장 메커니즘 구현 필요

## JWT 보안 강화 기법

### 1. 토큰 수명 관리

- **짧은 만료 시간 설정**: 액세스 토큰의 수명을 짧게(5~15분) 설정
- **리프레시 토큰 사용**: 장기간 세션 유지를 위해 리프레시 토큰 구현
- **토큰 순환(Token Rotation)**: 리프레시 토큰 사용 시 새로운 리프레시 토큰 발급

### 2. 서명 보안 강화

- **강력한 서명 알고리즘 사용**: 최소 HS256(HMAC-SHA256) 이상의 알고리즘 사용
- **충분한 키 길이 사용**: HMAC의 경우 최소 256비트, RSA의 경우 최소 2048비트
- **키 순환 정책 구현**: 정기적인 키 교체로 키 노출 위험 감소

### 3. 토큰 무효화 메커니즘

- **블랙리스트 구현**: Redis와 같은 인메모리 데이터베이스를 사용하여 무효화된 토큰 관리
- **토큰 버전 관리**: 사용자별 토큰 버전을 유지하여 이전 버전의 토큰 거부
- **JWT ID(jti) 사용**: 각 토큰에 고유 식별자를 부여하여 특정 토큰만 무효화

### 4. 추가 보안 계층

- **토큰 핑거프린팅**: 토큰의 일부만 클라이언트에 저장하고 나머지는 쿠키로 전송
- **CSRF 토큰 사용**: CSRF 공격 방지를 위한 추가 토큰 구현
- **토큰 바인딩**: 토큰을 특정 디바이스나 IP에 바인딩

## JWT와 인증 아키텍처

### 1. 단일 토큰 아키텍처

- **구성**: 단일 JWT 액세스 토큰만 사용
- **장점**: 구현이 간단하고 오버헤드가 적음
- **단점**: 토큰 만료 시 사용자 재인증 필요
- **적합한 경우**: 짧은 세션, 낮은 보안 요구사항

### 2. 리프레시 토큰 아키텍처

- **구성**: 짧은 수명의 액세스 토큰 + 긴 수명의 리프레시 토큰
- **작동 방식**:
    - 액세스 토큰 만료 시 리프레시 토큰으로 새 액세스 토큰 발급
    - 리프레시 토큰은 서버에 저장되어 필요시 무효화 가능
- **장점**: 향상된 보안과 사용자 경험 균형
- **단점**: 구현 복잡성 증가
- **적합한 경우**: 대부분의 웹 애플리케이션

### 3. 슬라이딩 세션 아키텍처

- **구성**: 사용자 활동에 따라 토큰 만료 시간이 연장됨
- **작동 방식**: 각 요청마다 새 토큰 발급 또는 만료 시간 갱신
- **장점**: 지속적인 사용자 경험 제공
- **단점**: 토큰 관리 복잡성 증가
- **적합한 경우**: 장기간 사용자 세션이 필요한 애플리케이션

## JWT와 다른 인증 방식 비교

### JWT vs 세션 기반 인증

| 특성 | JWT | 세션 기반 인증 |
|------|-----|--------------|
| 상태 저장 | Stateless | Stateful |
| 확장성 | 높음 | 낮음(세션 공유 필요) |
| 서버 부하 | 낮음(검증만 필요) | 높음(세션 조회 필요) |
| 구현 복잡성 | 중간 | 낮음 |
| 보안 | 중간(토큰 노출 위험) | 높음(서버에서 관리) |
| 토큰 무효화 | 어려움 | 쉬움 |
| 대역폭 사용 | 높음(토큰 크기) | 낮음(세션 ID만) |

### JWT vs OAuth 2.0

- **JWT**: 토큰 형식 및 구조에 대한 표준
- **OAuth 2.0**: 권한 부여 프레임워크
- **관계**: OAuth 2.0은 JWT를 토큰 형식으로 사용할 수 있음
- **차이점**:
    - JWT는 토큰 형식만 정의, OAuth는 전체 인증 흐름 정의
    - OAuth는 다양한 권한 부여 유형 지원(인증 코드, 암시적, 리소스 소유자 등)
    - OAuth는 제3자 애플리케이션 액세스에 중점, JWT는 일반적인 인증에 중점

### JWT vs SAML

- **JWT**: 경량, JSON 기반, REST API 친화적
- **SAML**: XML 기반, 엔터프라이즈 환경에서 널리 사용
- **차이점**:
    - JWT는 크기가 작고 모바일/웹 환경에 적합
    - SAML은 더 많은 기능과 보안 기능 제공
    - SAML은 기업 SSO에 더 적합, JWT는 API 인증에 더 적합

## JWT 구현 시 고려사항

### 1. 토큰 저장 위치

- **브라우저 환경**:
    - **HttpOnly 쿠키**: XSS 공격으로부터 보호, CSRF 취약성 존재
    - **로컬 스토리지/세션 스토리지**: 편리하지만 XSS에 취약
    - **메모리(JavaScript 변수)**: 페이지 새로고침 시 손실되지만 가장 안전

- **모바일 환경**:
    - **안전한 저장소**: iOS의 Keychain, Android의 EncryptedSharedPreferences
    - **인메모리 저장**: 앱 종료 시 손실되지만 안전

### 2. 토큰 전송 방법

- **Authorization 헤더**: `Authorization: Bearer <token>`
    - REST API에 적합
    - CORS 요청에 문제 없음
    - JavaScript로 쉽게 접근 가능(XSS 위험)

- **HttpOnly 쿠키**:
    - JavaScript에서 접근 불가(XSS 방지)
    - SameSite 속성으로 CSRF 위험 감소
    - 도메인 제한으로 인한 마이크로서비스 문제

### 3. 토큰 크기 최적화

- **최소한의 클레임만 포함**: 필요한 정보만 토큰에 포함
- **중첩된 객체 피하기**: 플랫 구조 사용
- **약어 사용**: 긴 클레임 이름 대신 짧은 약어 사용
- **압축 고려**: 일부 JWT 라이브러리는 페이로드 압축 지원

## 기억해두면 좋은 영어 표현

- "JWT provides a stateless authentication mechanism" - JWT는 상태 비저장 인증 메커니즘을 제공합니다
- "Claims are statements about an entity and additional metadata" - 클레임은 엔티티와 추가 메타데이터에 대한 명세입니다
- "Token-based authentication eliminates the need for server-side sessions" - 토큰 기반 인증은 서버 측 세션의 필요성을 제거합니다
- "JWT signature verification ensures token integrity" - JWT 서명 검증은 토큰 무결성을 보장합니다
- "Refresh token rotation enhances security by issuing new refresh tokens" - 리프레시 토큰 순환은 새 리프레시 토큰을 발급하여 보안을 강화합니다

## 영어로 질문하기

한글: "JWT 토큰의 보안을 강화하는 가장 효과적인 방법은 무엇인가요?"
영어: "What are the most effective ways to enhance the security of JWT tokens?"

한글: "JWT 토큰을 무효화하는 적절한 전략은 무엇인가요?"
영어: "What are appropriate strategies for invalidating JWT tokens?"

## 이직에 도움되는 정보

백엔드 개발자로서 JWT에 대한 깊은 이해는 다음과 같은 이유로 이직에 큰 도움이 됩니다:

1. **현대적 인증 시스템 설계 능력**: JWT에 대한 전문 지식은 확장 가능하고 안전한 인증 시스템을 설계할 수 있는 능력을 보여줍니다.

2. **마이크로서비스 아키텍처 경험**: JWT는 마이크로서비스 환경에서 널리 사용되므로, 이에 대한 깊은 이해는 현대적인 분산 시스템 경험을 나타냅니다.

3. **보안 의식**: JWT의 보안 측면에 대한 이해는 보안을 중요시하는 개발자임을 보여줍니다.

4. **API 설계 경험**: JWT는 RESTful API 인증에 널리 사용되므로, API 설계 및 구현 경험을 입증합니다.

5. **클라우드 서비스 통합 능력**: AWS Cognito, Auth0, Firebase Authentication 등 많은 클라우드 인증 서비스가 JWT를 사용하므로, 이러한 서비스와의 통합 경험을 강조할 수 있습니다.

이력서나 면접에서 JWT 관련 경험을 강조할 때는 단순히 기술을 사용했다는 것보다, 보안 강화, 확장성 개선, 사용자 경험 향상 등 비즈니스 가치를 어떻게 제공했는지 구체적인 사례를 포함하는 것이 효과적입니다.